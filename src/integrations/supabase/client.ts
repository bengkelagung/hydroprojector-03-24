// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://vtqxdgejqgyhhvnaxnfq.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZ0cXhkZ2VqcWd5aGh2bmF4bmZxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDIyNjMzMzMsImV4cCI6MjA1NzgzOTMzM30.yIqydW7F2KLiA6-OwwMP-AAD-wbAsFyqWPNhvy23G1w";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

/**
 * Check if a specific table exists in the Supabase database
 * @param tableName The name of the table to check
 * @returns A boolean indicating if the table exists
 */
export const checkIfTableExists = async (tableName: string): Promise<boolean> => {
  try {
    const { data, error } = await supabase.rpc('get_tables');
    if (error) {
      console.error('Error checking tables:', error);
      return false;
    }
    
    return data.some((table: { table_name: string }) => table.table_name === tableName);
  } catch (error) {
    console.error('Error in checkIfTableExists:', error);
    return false;
  }
};

/**
 * Check if all required tables exist
 * @returns A boolean indicating if all required tables exist
 */
export const checkTablesExist = async (): Promise<boolean> => {
  try {
    const requiredTables = [
      'profiles', 
      'projects', 
      'devices', 
      'pins', 
      'data_types', 
      'signal_types', 
      'modes', 
      'label', 
      'pin_configs', 
      'pin_data'
    ];
    
    const { data, error } = await supabase.rpc('get_tables');
    
    if (error) {
      console.error('Error checking tables:', error);
      return false;
    }
    
    const existingTables = data.map((table: { table_name: string }) => table.table_name);
    
    return requiredTables.every(table => existingTables.includes(table));
  } catch (error) {
    console.error('Error in checkTablesExist:', error);
    return false;
  }
};

/**
 * Check if the label_id column exists in the pin_configs table
 * @returns A boolean indicating if the label_id column exists
 */
export const checkLabelColumnExists = async (): Promise<boolean> => {
  try {
    // First check if the pin_configs table exists
    const tableExists = await checkIfTableExists('pin_configs');
    if (!tableExists) {
      return false;
    }
    
    // Use a direct query instead of the problematic RPC
    const { data, error } = await supabase
      .from('pin_configs')
      .select('label_id')
      .limit(1);
    
    if (error) {
      // If there's an error about the column not existing
      if (error.message.includes('column "label_id" does not exist')) {
        return false;
      }
      console.error('Error checking for label_id column:', error);
      return false;
    }
    
    // If we got here, the column exists
    return true;
  } catch (error) {
    console.error('Error in checkLabelColumnExists:', error);
    return false;
  }
};

/**
 * Create a profile for a user if it doesn't exist
 * @param userId The user ID to create a profile for
 * @returns A boolean indicating if the profile was created successfully
 */
export const ensureProfileExists = async (userId: string): Promise<boolean> => {
  try {
    // Check if profile exists
    const { data, error } = await supabase
      .from('profiles')
      .select('profile_id')
      .eq('user_id', userId)
      .maybeSingle();
    
    if (error) {
      console.error('Error checking profile:', error);
      return false;
    }
    
    // If profile exists, return true
    if (data) {
      return true;
    }
    
    // Create profile with correct RLS approach
    const { error: insertError } = await supabase.auth.getSession().then(async ({ data: sessionData }) => {
      if (!sessionData.session) {
        throw new Error('No active session');
      }
      
      return await supabase
        .from('profiles')
        .insert([{ user_id: userId }]);
    });
    
    if (insertError) {
      console.error('Error creating profile:', insertError);
      return false;
    }
    
    return true;
  } catch (error) {
    console.error('Error in ensureProfileExists:', error);
    return false;
  }
};

/**
 * Get default labels when database is not available
 * @returns Array of default labels
 */
export const getDefaultLabels = (): string[] => {
  return ['pH', 'Temperature', 'Humidity', 'Water Level', 'Nutrient', 'Light'];
};

/**
 * Fetch labels from the database
 * @returns Array of label names
 */
export const fetchLabelsFromDatabase = async (): Promise<string[]> => {
  try {
    // First check if the label table exists
    const tableExists = await checkIfTableExists('label');
    if (!tableExists) {
      return getDefaultLabels();
    }
    
    // Query directly from the label table instead of using the function
    const { data, error } = await supabase
      .from('label')
      .select('name')
      .order('name');
    
    if (error) {
      console.error('Error fetching labels from database:', error);
      return getDefaultLabels();
    }
    
    return data.map(label => label.name);
  } catch (error) {
    console.error('Error in fetchLabelsFromDatabase:', error);
    return getDefaultLabels();
  }
};

/**
 * Fetch pin configurations with related data
 * @param userId The user ID to filter by
 * @returns Array of pin configurations with related data
 */
export const fetchPinConfigsWithRelations = async (userId: string) => {
  try {
    // Instead of using RPC function with type issues, query directly
    const { data: projects } = await supabase
      .from('projects')
      .select('id')
      .eq('user_id', userId);
    
    if (!projects || projects.length === 0) {
      return [];
    }
    
    const projectIds = projects.map(p => p.id);
    
    const { data: devices } = await supabase
      .from('devices')
      .select('id')
      .in('project_id', projectIds);
    
    if (!devices || devices.length === 0) {
      return [];
    }
    
    const deviceIds = devices.map(d => d.id);
    
    const { data: pinConfigs, error } = await supabase
      .from('pin_configs')
      .select(`
        id, 
        device_id,
        pin_id,
        data_type_id,
        signal_type_id,
        mode_id,
        label_id,
        name,
        unit,
        value,
        last_updated,
        created_at,
        pins!inner(pin_number, pin_name),
        data_types!inner(name),
        signal_types!inner(name),
        modes!inner(type),
        label(name)
      `)
      .in('device_id', deviceIds);
    
    if (error) {
      console.error('Error fetching pin configs:', error);
      return [];
    }
    
    // Transform the data to match the expected format
    return pinConfigs.map(pc => ({
      id: pc.id,
      device_id: pc.device_id,
      pin_id: pc.pin_id,
      pin_number: pc.pins.pin_number,
      pin_name: pc.pins.pin_name,
      data_type_id: pc.data_type_id,
      data_type_name: pc.data_types.name,
      signal_type_id: pc.signal_type_id,
      signal_type_name: pc.signal_types.name,
      mode_id: pc.mode_id,
      mode_type: pc.modes.type,
      label_id: pc.label_id,
      label_name: pc.label?.name || null,
      name: pc.name,
      unit: pc.unit || '',
      value: pc.value || '',
      last_updated: pc.last_updated,
      created_at: pc.created_at
    }));
  } catch (error) {
    console.error('Error in fetchPinConfigsWithRelations:', error);
    return [];
  }
};

/**
 * Fetch pins with their information
 * @returns Array of pins with their information
 */
export const fetchPinsWithInfo = async () => {
  try {
    const { data, error } = await supabase
      .from('pins')
      .select('id, pin_name, pin_number')
      .order('pin_number');
    
    if (error) {
      console.error('Error fetching pins with info:', error);
      return [];
    }
    
    return data;
  } catch (error) {
    console.error('Error in fetchPinsWithInfo:', error);
    return [];
  }
};

/**
 * Fetch data types from the database
 * @returns Array of data type names
 */
export const fetchDataTypes = async (): Promise<string[]> => {
  try {
    const { data, error } = await supabase
      .from('data_types')
      .select('name')
      .order('name');
    
    if (error) {
      console.error('Error fetching data types:', error);
      return [];
    }
    
    return data.map(type => type.name);
  } catch (error) {
    console.error('Error in fetchDataTypes:', error);
    return [];
  }
};

/**
 * Fetch signal types from the database
 * @returns Array of signal type names
 */
export const fetchSignalTypes = async (): Promise<string[]> => {
  try {
    const { data, error } = await supabase
      .from('signal_types')
      .select('name')
      .order('name');
    
    if (error) {
      console.error('Error fetching signal types:', error);
      return [];
    }
    
    return data.map(type => type.name);
  } catch (error) {
    console.error('Error in fetchSignalTypes:', error);
    return [];
  }
};

/**
 * Fetch modes from the database
 * @returns Array of mode types
 */
export const fetchModes = async (): Promise<string[]> => {
  try {
    const { data, error } = await supabase
      .from('modes')
      .select('type')
      .order('type');
    
    if (error) {
      console.error('Error fetching modes:', error);
      return [];
    }
    
    return data.map(mode => mode.type);
  } catch (error) {
    console.error('Error in fetchModes:', error);
    return [];
  }
};

/**
 * Find data type ID by name
 * @param name The name of the data type
 * @returns The ID of the data type or null if not found
 */
export const findDataTypeIdByName = async (name: string): Promise<number | null> => {
  try {
    if (!name || name.trim() === '') {
      console.error('Invalid data type name provided');
      return null;
    }

    const { data, error } = await supabase
      .from('data_types')
      .select('id')
      .eq('name', name.trim())
      .single();
    
    if (error) {
      console.error('Error finding data type ID:', error);
      return null;
    }
    
    return data.id;
  } catch (error) {
    console.error('Error in findDataTypeIdByName:', error);
    return null;
  }
};

/**
 * Find signal type ID by name
 * @param name The name of the signal type
 * @returns The ID of the signal type or null if not found
 */
export const findSignalTypeIdByName = async (name: string): Promise<number | null> => {
  try {
    if (!name || name.trim() === '') {
      console.error('Invalid signal type name provided');
      return null;
    }

    const { data, error } = await supabase
      .from('signal_types')
      .select('id')
      .eq('name', name.trim())
      .single();
    
    if (error) {
      console.error('Error finding signal type ID:', error);
      
      // If the signal type doesn't exist, try to create it
      if (error.code === 'PGRST116') {
        const { data: insertData, error: insertError } = await supabase
          .from('signal_types')
          .insert({ name: name.trim() })
          .select('id')
          .single();
        
        if (insertError) {
          console.error('Error creating signal type:', insertError);
          return null;
        }
        
        return insertData.id;
      }
      
      return null;
    }
    
    return data.id;
  } catch (error) {
    console.error('Error in findSignalTypeIdByName:', error);
    return null;
  }
};

/**
 * Find mode ID by type
 * @param type The type of the mode
 * @returns The ID of the mode or null if not found
 */
export const findModeIdByType = async (type: string): Promise<number | null> => {
  try {
    if (!type || type.trim() === '') {
      console.error('Invalid mode type provided');
      return null;
    }

    const { data, error } = await supabase
      .from('modes')
      .select('id')
      .eq('type', type.trim())
      .single();
    
    if (error) {
      console.error('Error finding mode ID:', error);
      return null;
    }
    
    return data.id;
  } catch (error) {
    console.error('Error in findModeIdByType:', error);
    return null;
  }
};

/**
 * Find label ID by name
 * @param name The name of the label
 * @returns The ID of the label or null if not found
 */
export const findLabelIdByName = async (name: string): Promise<number | null> => {
  try {
    if (!name || name.trim() === '') {
      console.error('Invalid label name provided');
      return null;
    }

    const { data, error } = await supabase
      .from('label')
      .select('id')
      .eq('name', name.trim())
      .single();
    
    if (error) {
      console.error('Error finding label ID:', error);
      
      // If the label doesn't exist, try to create it
      if (error.code === 'PGRST116') {
        const { data: insertData, error: insertError } = await supabase
          .from('label')
          .insert({ name: name.trim() })
          .select('id')
          .single();
        
        if (insertError) {
          console.error('Error creating label:', insertError);
          return null;
        }
        
        return insertData.id;
      }
      
      return null;
    }
    
    return data.id;
  } catch (error) {
    console.error('Error in findLabelIdByName:', error);
    return null;
  }
};

/**
 * Find pin ID by number
 * @param pinNumber The pin number
 * @returns The ID of the pin or null if not found
 */
export const findPinIdByNumber = async (pinNumber: number): Promise<string | null> => {
  try {
    const { data, error } = await supabase
      .from('pins')
      .select('id')
      .eq('pin_number', pinNumber)
      .single();
    
    if (error) {
      console.error('Error finding pin ID:', error);
      return null;
    }
    
    return data.id;
  } catch (error) {
    console.error('Error in findPinIdByNumber:', error);
    return null;
  }
};

/**
 * Get pin history data for charts
 * @param pinId - ID of the pin
 * @param hours - Number of hours of history to fetch
 * @returns Array of history data
 */
export const getPinHistoryData = async (pinId: string, hours: number = 24) => {
  try {
    const startDate = new Date();
    startDate.setHours(startDate.getHours() - hours);
    
    const startDateStr = startDate.toISOString();
    
    // Determine maximum number of records based on time range
    const maxRecords = hours <= 6 ? 200 : hours <= 24 ? 500 : 1000;
    
    // For long time ranges, use different sampling strategies to improve performance
    if (hours > 24) {
      // Try to use the database function for sampling if available
      try {
        const { data, error } = await supabase
          .rpc('get_pin_data_sampled', { 
            pin_id: pinId, 
            start_time: startDateStr,
            max_points: maxRecords
          });
          
        if (!error && data && data.length > 0) {
          return data;
        }
      } catch (e) {
        console.log('Sampling function not available, using fallback method');
      }
    }
    
    // Fallback method - direct query with limit
    const { data, error } = await supabase
      .from('pin_data')
      .select('id, pin_config_id, value, created_at')
      .eq('pin_config_id', pinId)
      .gte('created_at', startDateStr)
      .order('created_at', { ascending: false })
      .limit(maxRecords);
      
    if (error) {
      console.error('Error fetching pin history data:', error);
      return [];
    }
    
    // Reverse to get chronological order
    return data ? data.reverse() : [];
    
  } catch (error) {
    console.error('Error in getPinHistoryData:', error);
    return [];
  }
};

/**
 * Fallback method to get pin history data without using RPC
 */
const getPinHistoryDataFallback = async (pinId: string, timeAgo: Date, maxRecords: number) => {
  try {
    const { data, error } = await supabase
      .from('pin_data')
      .select('created_at, value')
      .eq('pin_config_id', pinId)
      .gte('created_at', timeAgo.toISOString())
      .order('created_at', { ascending: true })
      .limit(maxRecords);
    
    if (error) {
      console.error('Error fetching pin history data:', error);
      return [];
    }
    
    return data || [];
  } catch (error) {
    console.error('Error in getPinHistoryDataFallback:', error);
    return [];
  }
};
